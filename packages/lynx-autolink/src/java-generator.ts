import * as fs from "node:fs";
import * as path from "node:path";
import type { LynxModuleMetadata } from "./types.js";

/**
 * Convert a fully-qualified Java class name to just the simple class name.
 * "com.kafitra.lynxdeviceinfo.LynxDeviceInfoModule" → "LynxDeviceInfoModule"
 */
function simpleClassName(fqcn: string): string {
  return fqcn.split(".").at(-1) ?? fqcn;
}

/**
 * Convert a Java package name (dot-separated) to a directory path.
 * "com.kafitra.demo" → "com/kafitra/demo"
 */
function packageToPath(javaPackage: string): string {
  return javaPackage.split(".").join("/");
}

/**
 * Generate the source code for `LynxAutolinkRegistry.java`.
 *
 * @param modules     - List of detected Lynx modules.
 * @param javaPackage - Java package for the generated class (matches the host app's applicationId).
 * @returns           Java source code as a string.
 */
export function generateJavaRegistry(
  modules: LynxModuleMetadata[],
  javaPackage: string,
): string {
  if (modules.length === 0) {
    return [
      `package ${javaPackage};`,
      "",
      "/**",
      " * Auto-generated by @kafitra/lynx-autolink.",
      " * Run `npx @kafitra/lynx-cli link` to regenerate.",
      " * DO NOT EDIT MANUALLY.",
      " */",
      "public class LynxAutolinkRegistry {",
      "    public static void registerAll() {",
      "        // No Lynx Native Modules found.",
      "    }",
      "}",
    ].join("\n");
  }

  // Deduplicate import class names
  const importSet = new Set<string>();
  const hasBehavior = modules.some((m) => m.android.componentClass);
  for (const mod of modules) {
    if (mod.android.moduleClass) importSet.add(mod.android.moduleClass);
    if (mod.android.componentClass) importSet.add(mod.android.componentClass);
  }
  const imports = Array.from(importSet)
    .sort()
    .map((fqcn) => `import ${fqcn};`)
    .join("\n");

  const moduleRegistrations = modules
    .flatMap((mod) => {
      const lines: string[] = [];
      if (mod.android.moduleClass) {
        const className = simpleClassName(mod.android.moduleClass);
        lines.push(
          `        LynxEnv.inst().registerModule(\n            "${mod.name}",\n            ${className}.class\n        );`,
        );
      }
      return lines;
    })
    .join("\n");

  const uiBehaviors = modules
    .flatMap((mod) => {
      const lines: string[] = [];
      if (mod.android.componentClass) {
        const className = simpleClassName(mod.android.componentClass);
        const tag = mod.android.componentTag ?? mod.name.toLowerCase();
        lines.push(
          `        builder.addBehavior(new com.lynx.tasm.behavior.Behavior("${tag}") {\n            @Override\n            public com.lynx.tasm.behavior.ui.LynxUI createUI(com.lynx.tasm.behavior.LynxContext context) {\n                return new ${className}(context);\n            }\n        });`,
        );
      }
      return lines;
    })
    .join("\n");

  const uiMethod = hasBehavior
    ? [
        "    /**",
        "     * Register all native UI components with a LynxViewBuilder.",
        "     * Call this in your Activity after creating the LynxViewBuilder,",
        "     * before calling LynxViewBuilder.build().",
        "     */",
        "    public static void addUIBehaviorsTo(com.lynx.tasm.LynxViewBuilder builder) {",
        uiBehaviors || "        // no UI components",
        "    }",
      ].join("\n")
    : "";

  return [
    `package ${javaPackage};`,
    "",
    "import com.lynx.tasm.LynxEnv;",
    "",
    imports,
    "",
    "/**",
    " * Auto-generated by @kafitra/lynx-autolink.",
    " * Run `npx @kafitra/lynx-cli link` to regenerate.",
    " * DO NOT EDIT MANUALLY.",
    " */",
    "public class LynxAutolinkRegistry {",
    "    public static void registerAll() {",
    moduleRegistrations || "        // no modules",
    "    }",
    uiMethod,
    "}",
  ].join("\n");
}

/**
 * Attempt to read the `applicationId` from an `app/build.gradle` file.
 * Returns `null` if not found.
 */
export function readApplicationId(buildGradlePath: string): string | null {
  if (!fs.existsSync(buildGradlePath)) return null;
  const content = fs.readFileSync(buildGradlePath, "utf8");
  const match = content.match(/applicationId\s+["']([^"']+)["']/);
  return match ? match[1]! : null;
}

/**
 * Write `LynxAutolinkRegistry.java` into the correct directory under `androidAppDir`.
 *
 * @param androidAppDir - Absolute path to the `app/` directory (contains `build.gradle`).
 * @param javaPackage   - Java package name (e.g. "com.kafitra.demo"). If not supplied,
 *                        it is inferred from `applicationId` in `build.gradle`.
 * @param modules       - List of detected Lynx modules.
 */
export function writeJavaRegistry(
  androidAppDir: string,
  javaPackage: string | undefined,
  modules: LynxModuleMetadata[],
): void {
  let pkg = javaPackage;
  if (!pkg) {
    const buildGradle = path.join(androidAppDir, "build.gradle");
    pkg = readApplicationId(buildGradle) ?? undefined;
  }
  if (!pkg) {
    throw new Error(
      "[lynx-autolink] Could not determine Java package. " +
        "Pass --java-package explicitly or ensure applicationId is set in app/build.gradle.",
    );
  }

  const source = generateJavaRegistry(modules, pkg);
  const outRelative = path.join(
    "src",
    "main",
    "java",
    packageToPath(pkg),
    "LynxAutolinkRegistry.java",
  );
  const outPath = path.join(androidAppDir, outRelative);

  fs.mkdirSync(path.dirname(outPath), { recursive: true });
  fs.writeFileSync(outPath, source + "\n", "utf8");
}
