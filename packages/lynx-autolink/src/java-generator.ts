import * as fs from "node:fs";
import * as path from "node:path";
import type { LynxModuleMetadata } from "./types.js";

/**
 * Convert a fully-qualified Java class name to just the simple class name.
 * "com.kafitra.lynxdeviceinfo.LynxDeviceInfoModule" → "LynxDeviceInfoModule"
 */
function simpleClassName(fqcn: string): string {
  return fqcn.split(".").at(-1) ?? fqcn;
}

/**
 * Convert a Java package name (dot-separated) to a directory path.
 * "com.kafitra.demo" → "com/kafitra/demo"
 */
function packageToPath(javaPackage: string): string {
  return javaPackage.split(".").join("/");
}

/**
 * Generate the source code for `LynxAutolinkRegistry.java`.
 *
 * @param modules     - List of detected Lynx modules.
 * @param javaPackage - Java package for the generated class (matches the host app's applicationId).
 * @returns           Java source code as a string.
 */
export function generateJavaRegistry(
  modules: LynxModuleMetadata[],
  javaPackage: string,
): string {
  if (modules.length === 0) {
    return [
      `package ${javaPackage};`,
      "",
      "import com.lynx.tasm.LynxEnv;",
      "",
      "/**",
      " * Auto-generated by @kafitra/lynx-autolink.",
      " * Run `npx @kafitra/lynx-cli link` to regenerate.",
      " * DO NOT EDIT MANUALLY.",
      " */",
      "public class LynxAutolinkRegistry {",
      "    public static void registerAll() {",
      "        // No Lynx Native Modules found.",
      "    }",
      "}",
    ].join("\n");
  }

  // Deduplicate import class names
  const importSet = new Set<string>();
  for (const mod of modules) {
    importSet.add(mod.android.moduleClass);
  }
  const imports = Array.from(importSet)
    .sort()
    .map((fqcn) => `import ${fqcn};`)
    .join("\n");

  const registrations = modules
    .map((mod) => {
      const className = simpleClassName(mod.android.moduleClass);
      return `        LynxEnv.inst().registerModule(\n            "${mod.name}",\n            ${className}.class\n        );`;
    })
    .join("\n");

  return [
    `package ${javaPackage};`,
    "",
    "import com.lynx.tasm.LynxEnv;",
    "",
    imports,
    "",
    "/**",
    " * Auto-generated by @kafitra/lynx-autolink.",
    " * Run `npx @kafitra/lynx-cli link` to regenerate.",
    " * DO NOT EDIT MANUALLY.",
    " */",
    "public class LynxAutolinkRegistry {",
    "    public static void registerAll() {",
    registrations,
    "    }",
    "}",
  ].join("\n");
}

/**
 * Attempt to read the `applicationId` from an `app/build.gradle` file.
 * Returns `null` if not found.
 */
export function readApplicationId(buildGradlePath: string): string | null {
  if (!fs.existsSync(buildGradlePath)) return null;
  const content = fs.readFileSync(buildGradlePath, "utf8");
  const match = content.match(/applicationId\s+["']([^"']+)["']/);
  return match ? match[1]! : null;
}

/**
 * Write `LynxAutolinkRegistry.java` into the correct directory under `androidAppDir`.
 *
 * @param androidAppDir - Absolute path to the `app/` directory (contains `build.gradle`).
 * @param javaPackage   - Java package name (e.g. "com.kafitra.demo"). If not supplied,
 *                        it is inferred from `applicationId` in `build.gradle`.
 * @param modules       - List of detected Lynx modules.
 */
export function writeJavaRegistry(
  androidAppDir: string,
  javaPackage: string | undefined,
  modules: LynxModuleMetadata[],
): void {
  let pkg = javaPackage;
  if (!pkg) {
    const buildGradle = path.join(androidAppDir, "build.gradle");
    pkg = readApplicationId(buildGradle) ?? undefined;
  }
  if (!pkg) {
    throw new Error(
      "[lynx-autolink] Could not determine Java package. " +
        "Pass --java-package explicitly or ensure applicationId is set in app/build.gradle.",
    );
  }

  const source = generateJavaRegistry(modules, pkg);
  const outRelative = path.join(
    "src",
    "main",
    "java",
    packageToPath(pkg),
    "LynxAutolinkRegistry.java",
  );
  const outPath = path.join(androidAppDir, outRelative);

  fs.mkdirSync(path.dirname(outPath), { recursive: true });
  fs.writeFileSync(outPath, source + "\n", "utf8");
}
